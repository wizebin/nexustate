(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("nexusdk", [], factory);
	else if(typeof exports === 'object')
		exports["nexusdk"] = factory();
	else
		root["nexusdk"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/clone/clone.js":
/*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n\n\n//# sourceURL=webpack://nexusdk/./node_modules/clone/clone.js?");

/***/ }),

/***/ "./node_modules/objer/dist/src/node.index.js":
/*!***************************************************!*\
  !*** ./node_modules/objer/dist/src/node.index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(global, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/index.js\":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.set = set;\\nexports.keys = keys;\\nexports.pick = pick;\\nexports.assassinate = assassinate;\\nexports.clone = clone;\\nexports.omit = omit;\\nexports.values = values;\\nexports.has = has;\\nexports.hasRoot = hasRoot;\\nexports.get = get;\\nexports.yank = yank;\\nexports.getObjectPath = getObjectPath;\\nexports.getStringPathForArray = getStringPathForArray;\\nexports.assurePathExists = assurePathExists;\\nexports.getTypeString = getTypeString;\\nexports.deepEq = deepEq;\\nexports.shallowDiff = shallowDiff;\\nexports.default = void 0;\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n/**\\n * Objer module, interact with objects\\n * @module objer\\n */\\n\\n/**\\n * Set value at an object subpath\\n * @param {Object} object\\n * @param {string|array} path\\n * @param {*} value\\n */\\nfunction set(object, path, value) {\\n  var subObject = object;\\n  var keys = getObjectPath(path);\\n  if (keys.length === 0) return value; // We cannot modify the original value to be the new value no matter how hard we try\\n\\n  for (var keydex = 0; keydex < keys.length; keydex += 1) {\\n    var key = keys[keydex];\\n\\n    if (key !== '') {\\n      if (keydex !== keys.length - 1) {\\n        if (subObject[key] === null || _typeof(subObject[key]) !== 'object') {\\n          subObject[key] = {};\\n        }\\n\\n        subObject = subObject[key];\\n      } else {\\n        subObject[key] = value;\\n      }\\n    }\\n  }\\n\\n  return object;\\n}\\n/**\\n * Get array of keys in an object\\n * @param {Object} object\\n */\\n\\n\\nfunction keys(object) {\\n  var stringType = getTypeString(object);\\n\\n  if (stringType === 'object' || stringType === 'array') {\\n    if (typeof Object.keys !== 'undefined') return Object.keys(object);\\n    var _keys = [];\\n\\n    for (var key in object) {\\n      if (object.hasOwnProperty(key)) {\\n        _keys.push(key);\\n      }\\n    }\\n\\n    return _keys;\\n  }\\n\\n  return [];\\n}\\n/**\\n * Create an object with selected keys and values from an input object\\n * @param {*} object\\n * @param {array} whitelistedKeys\\n */\\n\\n\\nfunction pick(object, whitelistedKeys) {\\n  var result = {};\\n  if (!whitelistedKeys) return result;\\n  var key = void 0;\\n\\n  for (var keydex = 0; keydex < whitelistedKeys.length; keydex += 1) {\\n    key = whitelistedKeys[keydex];\\n\\n    if (has(object, key)) {\\n      set(result, key, get(object, key));\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nfunction assassinate(source, path) {\\n  var pathArray = getObjectPath(path);\\n\\n  if (pathArray.length > 0) {\\n    var parentPath = pathArray.slice(0, pathArray.length - 1);\\n\\n    if (has(source, parentPath) || parentPath.length === 0) {\\n      var original = get(source, parentPath);\\n      var originalType = getTypeString(original);\\n      var pathKey = pathArray[pathArray.length - 1];\\n\\n      if (originalType === 'object') {\\n        delete original[pathKey];\\n      } else if (originalType === 'array' && typeof pathKey === 'number') {\\n        original.splice(pathKey, 1);\\n      }\\n    }\\n  }\\n\\n  return source;\\n}\\n\\nfunction clone(source) {\\n  var stringType = getTypeString(source);\\n\\n  if (stringType === 'object') {\\n    var sourceKeys = keys(source);\\n    var result = {};\\n\\n    for (var keydex = 0; keydex < sourceKeys.length; keydex += 1) {\\n      result[sourceKeys[keydex]] = clone(source[sourceKeys[keydex]]);\\n    }\\n\\n    return result;\\n  } else if (stringType === 'array') {\\n    var length = source.length;\\n    var _result = [];\\n\\n    for (var dex = 0; dex < length; dex += 1) {\\n      _result.push(clone(source[dex]));\\n    }\\n\\n    return _result;\\n  }\\n\\n  return source;\\n}\\n/**\\n * Create an object without selected keys and values from an input object, DEEP CLONES OBJECT\\n * @param {*} object\\n * @param {array} whitelistedKeys\\n */\\n\\n\\nfunction omit(object, blacklistedKeys) {\\n  if (!blacklistedKeys) return object;\\n  var result = clone(object);\\n\\n  for (var keydex = 0; keydex < blacklistedKeys.length; keydex += 1) {\\n    assassinate(result, blacklistedKeys[keydex]);\\n  }\\n\\n  return result;\\n}\\n/**\\n * Get array of values in an object, passing an array will return the original array, anything else will return a blank array\\n * @param {Object} object\\n */\\n\\n\\nfunction values(object) {\\n  var stringType = getTypeString(object);\\n\\n  if (stringType === 'object') {\\n    var objectKeys = keys(object);\\n    var result = [];\\n\\n    for (var keydex = 0; keydex < objectKeys.length; keydex += 1) {\\n      result.push(object[objectKeys[keydex]]);\\n    }\\n\\n    return result;\\n  } else if (stringType === 'array') {\\n    return object;\\n  }\\n\\n  return [];\\n}\\n/**\\n * Check if an object has a value at a path\\n * @param {Object} object\\n * @param {string|array} path\\n */\\n\\n\\nfunction has(object, path) {\\n  var subObject = object;\\n  var keys = getObjectPath(path);\\n  if (keys.length === 0) return false;\\n\\n  for (var keydex = 0; keydex < keys.length; keydex += 1) {\\n    var key = keys[keydex];\\n    if (!hasRoot(subObject, key)) return false;\\n    subObject = subObject[key];\\n  }\\n\\n  return true;\\n}\\n/**\\n * Check if an object has a top level key, hasRoot({ a: 1 }, 'a'); is true, hasRoot({ a: { b: 1 } }, 'a.b'); is false\\n * @param {Object} object\\n * @param {string} key\\n */\\n\\n\\nfunction hasRoot(object, key) {\\n  if (object !== null && _typeof(object) === 'object') {\\n    return key in object;\\n  }\\n\\n  return false;\\n}\\n/**\\n * Retrieve value from within an object or array\\n * @param {Object} object\\n * @param {string|array} path\\n * @param {*} [defaultValue]\\n */\\n\\n\\nfunction get(object, path) {\\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\\n  var subObject = object;\\n  var keys = getObjectPath(path);\\n\\n  for (var keydex = 0; keydex < keys.length; keydex += 1) {\\n    var key = keys[keydex];\\n\\n    if (key !== '') {\\n      if (!hasRoot(subObject, key)) return defaultValue;\\n      subObject = subObject[key];\\n    }\\n  }\\n\\n  return subObject;\\n}\\n/**\\n * Retrieve subobject at path, if the key is null or undefined, the default value or undefined will be returned\\n * @param {Object} object\\n * @param {string|array} path\\n * @param {*} [defaultValue]\\n */\\n\\n\\nfunction yank(object, path) {\\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\\n  var stringType = getTypeString(path);\\n  if (stringType !== 'string' && stringType !== 'array' && stringType !== 'number') return defaultValue;\\n  var subObject = object;\\n  var keys = getObjectPath(path);\\n\\n  for (var keydex = 0; keydex < keys.length; keydex += 1) {\\n    var key = keys[keydex];\\n\\n    if (key !== '') {\\n      if (!hasRoot(subObject, key)) return defaultValue;\\n      subObject = subObject[key];\\n    }\\n  }\\n\\n  return subObject;\\n}\\n/**\\n * Resolve a path to a path array 'a.b.c' returns ['a', 'b', 'c']\\n * @param {string|array} path\\n */\\n\\n\\nfunction getObjectPath(path) {\\n  var inputType = getTypeString(path);\\n  if (inputType === 'array') return path;\\n\\n  if (inputType !== 'string') {\\n    if (inputType === 'number') return [path];\\n    return [];\\n  }\\n\\n  var inBrackets = false;\\n  var partBegin = 0;\\n  var split = false;\\n  var exitBrackets = false;\\n  var pathlen = path.length;\\n  var parts = [];\\n\\n  for (var dex = 0; dex < pathlen + 1; dex += 1) {\\n    var char = path[dex];\\n\\n    if (inBrackets && !exitBrackets) {\\n      if (char === ']') {\\n        exitBrackets = true;\\n      }\\n    } else if (char === '.') {\\n      split = true;\\n    } else if (char === '[') {\\n      split = true;\\n      inBrackets = true;\\n    }\\n\\n    if (split || dex === pathlen) {\\n      var nextPart = path.substr(partBegin, dex - partBegin - (exitBrackets ? 1 : 0));\\n\\n      if (inBrackets) {\\n        var parsed = parseInt(nextPart, 10);\\n\\n        if (!isNaN(parsed)) {\\n          nextPart = parsed;\\n        }\\n      }\\n\\n      parts.push(nextPart);\\n      partBegin = dex + 1;\\n      split = false;\\n      if (exitBrackets) inBrackets = false;\\n      exitBrackets = false;\\n    }\\n  }\\n\\n  return parts;\\n}\\n/**\\n * Convert an array into a string path ['a', 'b', 'c'] returns 'a.b.c'\\n * @param {array} arrayPath\\n */\\n\\n\\nfunction getStringPathForArray(arrayPath) {\\n  var inputType = getTypeString(arrayPath);\\n\\n  if (inputType !== 'array') {\\n    if (inputType === 'string') return arrayPath;\\n    if (inputType === 'number') return \\\"[\\\".concat(arrayPath, \\\"]\\\");\\n    return '';\\n  }\\n\\n  return arrayPath.reduce(function (result, item, dex) {\\n    if (getTypeString(item) === 'number') {\\n      return \\\"\\\".concat(result, \\\"[\\\").concat(item, \\\"]\\\");\\n    }\\n\\n    return result + (dex > 0 ? '.' : '') + item;\\n  }, '');\\n}\\n/**\\n * If this subkey doesn't exist, initialize it to defaultValue\\n * @param {Object} object\\n * @param {string|array} path\\n * @param {*} defaultValue\\n */\\n\\n\\nfunction assurePathExists(object, path) {\\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\\n  var arrayPath = getObjectPath(path);\\n  var currentObject = object;\\n\\n  for (var arraydex = 0; arraydex < arrayPath.length; arraydex += 1) {\\n    var key = arrayPath[arraydex];\\n\\n    if (!hasRoot(currentObject, key)) {\\n      // TODO: Address problems where key exists already and is not an array or object\\n      var nextKey = arraydex === arrayPath.length - 1 ? null : arrayPath[arraydex + 1];\\n\\n      if (nextKey === null) {\\n        currentObject[key] = defaultValue;\\n      } else if (getTypeString(nextKey) === 'number') {\\n        currentObject[key] = [];\\n      } else {\\n        currentObject[key] = {};\\n      }\\n    }\\n\\n    currentObject = currentObject[key];\\n  }\\n\\n  return currentObject;\\n}\\n/**\\n * Return simplified type as a string. [] returns 'array' new Date() returns 'date'\\n * @param {*} data\\n */\\n\\n\\nfunction getTypeString(data) {\\n  var stringType = _typeof(data);\\n\\n  if (stringType === 'object') {\\n    if (data === null) return 'null';\\n    var stringified = toString.apply(data);\\n\\n    if (stringified.length > 2 && stringified[0] === '[' && stringified[stringified.length - 1] === ']') {\\n      var splits = stringified.substr(1, stringified.length - 2).split(' ');\\n\\n      if (splits.length > 1) {\\n        return splits.slice(1).join(' ').toLowerCase();\\n      }\\n    }\\n\\n    return 'unknown';\\n  }\\n\\n  if (stringType === 'number') {\\n    if (isNaN(data)) return 'nan';\\n  }\\n\\n  return stringType;\\n}\\n/**\\n * Check if both parameters are equal, check all nested keys of objects and arrays\\n * @param {*} obja\\n * @param {*} objb\\n */\\n\\n\\nfunction deepEq(left, right) {\\n  var leftType = getTypeString(left);\\n  var rightType = getTypeString(right);\\n  if (leftType !== rightType) return false;\\n  if (leftType === 'nan') return true;\\n\\n  if (leftType === 'object') {\\n    if (left === right) return true; // if they are the same thing, don't check children\\n\\n    var leftKeys = keys(left).sort(); // unsorted could be unequal\\n\\n    var rightKeys = keys(right).sort();\\n    if (!deepEq(leftKeys, rightKeys)) return false;\\n\\n    for (var keydex = 0; keydex < leftKeys.length; keydex += 1) {\\n      if (!deepEq(left[leftKeys[keydex]], right[leftKeys[keydex]])) return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  if (leftType === 'array') {\\n    if (left === right) return true; // if they are the same thing, don't check children\\n\\n    if (left.length !== right.length) return false;\\n\\n    for (var dex = 0; dex < left.length; dex += 1) {\\n      if (!deepEq(left[dex], right[dex])) return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  return left === right;\\n}\\n/**\\n * Detect differences between two things, will indicate changes in type, value, length, etc. Will not diff string values.\\n * @param {*} original\\n * @param {*} incoming\\n */\\n\\n\\nfunction shallowDiff(original, incoming) {\\n  var currentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\\n  var changes = [];\\n  var originalType = getTypeString(original);\\n  var incomingType = getTypeString(incoming);\\n  if (originalType !== incomingType) return [{\\n    change: 'type',\\n    path: currentPath,\\n    original: original,\\n    incoming: incoming\\n  }];\\n  if (originalType === 'nan') return [];\\n\\n  if (originalType === 'object') {\\n    if (original === incoming) return []; // if they are the same thing, don't check children\\n\\n    var originalKeys = keys(original).sort(); // unsorted could be unequal\\n\\n    var incomingKeys = keys(incoming).sort();\\n    var sharedKeys = [];\\n\\n    if (!deepEq(originalKeys, incomingKeys)) {\\n      for (var originalDex = originalKeys.length - 1; originalDex >= 0; originalDex -= 1) {\\n        var originalKey = originalKeys[originalDex];\\n\\n        for (var incomingDex = incomingKeys.length - 1; incomingDex >= 0; incomingDex -= 1) {\\n          if (originalKey === incomingKeys[incomingDex]) {\\n            sharedKeys.push(originalKey);\\n            originalKeys.splice(originalDex, 1);\\n            incomingKeys.splice(incomingDex, 1);\\n            break;\\n          }\\n        }\\n      }\\n\\n      for (var _originalDex = 0; _originalDex < originalKeys.length; _originalDex += 1) {\\n        changes.push({\\n          change: 'delete',\\n          path: currentPath,\\n          key: originalKeys[_originalDex],\\n          original: original[originalKeys[_originalDex]]\\n        });\\n      }\\n\\n      for (var _incomingDex = 0; _incomingDex < incomingKeys.length; _incomingDex += 1) {\\n        changes.push({\\n          change: 'add',\\n          path: currentPath,\\n          key: incomingKeys[_incomingDex],\\n          incoming: incoming[incomingKeys[_incomingDex]]\\n        });\\n      }\\n    } else {\\n      sharedKeys = originalKeys;\\n    }\\n\\n    for (var keydex = 0; keydex < sharedKeys.length; keydex += 1) {\\n      changes = changes.concat(shallowDiff(original[sharedKeys[keydex]], incoming[sharedKeys[keydex]], currentPath.concat(sharedKeys[keydex])));\\n    }\\n  } else if (originalType === 'array') {\\n    if (original === incoming) return []; // if they are the same thing, don't check children\\n\\n    var sharedLength = original.length;\\n\\n    if (original.length !== incoming.length) {\\n      if (original.length > incoming.length) {\\n        sharedLength = incoming.length;\\n        changes.push({\\n          change: 'shrink',\\n          path: currentPath,\\n          original: original.slice(incoming.length)\\n        });\\n      } else {\\n        changes.push({\\n          change: 'grow',\\n          path: currentPath,\\n          incoming: incoming.slice(original.length)\\n        });\\n      }\\n    }\\n\\n    for (var dex = 0; dex < sharedLength; dex += 1) {\\n      changes = changes.concat(shallowDiff(original[dex], incoming[dex], currentPath.concat(dex)));\\n    }\\n  } else if (original === incoming) {\\n    return [];\\n  } else {\\n    return [{\\n      change: 'value',\\n      path: currentPath,\\n      original: original,\\n      incoming: incoming\\n    }];\\n  }\\n\\n  return changes;\\n}\\n\\nvar _default = {\\n  assurePathExists: assurePathExists,\\n  deepEq: deepEq,\\n  get: get,\\n  getObjectPath: getObjectPath,\\n  getStringPathForArray: getStringPathForArray,\\n  getTypeString: getTypeString,\\n  has: has,\\n  hasRoot: hasRoot,\\n  keys: keys,\\n  set: set,\\n  yank: yank\\n};\\nexports.default = _default;\\n\\n//# sourceURL=webpack://nexusdk/./src/index.js?\");\n\n/***/ })\n\n/******/ });\n});\n\n//# sourceURL=webpack://nexusdk/./node_modules/objer/dist/src/node.index.js?");

/***/ }),

/***/ "./src/Nexustate.js":
/*!**************************!*\
  !*** ./src/Nexustate.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.getLocalStorageSaveFunc = getLocalStorageSaveFunc;\nexports.getLocalStorageLoadFunc = getLocalStorageLoadFunc;\n\nvar _objer = __webpack_require__(/*! objer */ \"./node_modules/objer/dist/src/node.index.js\");\n\nvar _NexustateHelpers = __webpack_require__(/*! ./NexustateHelpers */ \"./src/NexustateHelpers.js\");\n\nvar _StorageManager = __webpack_require__(/*! ./StorageManager */ \"./src/StorageManager.js\");\n\nvar _StorageManager2 = _interopRequireDefault(_StorageManager);\n\nvar _blankKey = __webpack_require__(/*! ./utility/blankKey */ \"./src/utility/blankKey.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SAVE_THROTTLE_TIME = 100;\n\nfunction missingCallback() {\n  console.error('Nexustate missing saveCallback', new Error().stack);\n}\n\nfunction getLocalStorageSaveFunc() {\n  if (typeof global !== 'undefined' && typeof global.localStorage !== 'undefined') {\n    return function (key, data) {\n      return global.localStorage.setItem(key, JSON.stringify(data));\n    };\n  } else if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {\n    return function (key, data) {\n      return window.localStorage.setItem(key, JSON.stringify(data));\n    };\n  }\n}\n\nfunction getLocalStorageLoadFunc() {\n  if (typeof global !== 'undefined' && typeof global.localStorage !== 'undefined') {\n    return function (key) {\n      return JSON.parse(global.localStorage.getItem(key));\n    };\n  } else if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {\n    return function (key) {\n      return JSON.parse(window.localStorage.getItem(key));\n    };\n  }\n}\n\nvar DEFAULT_OPTIONS = { immediatePersist: false, noNotify: false };\n\nvar Nexustate = function () {\n  function Nexustate() {\n    var _this = this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$saveCallback = _ref.saveCallback,\n        saveCallback = _ref$saveCallback === undefined ? null : _ref$saveCallback,\n        _ref$loadCallback = _ref.loadCallback,\n        loadCallback = _ref$loadCallback === undefined ? null : _ref$loadCallback,\n        _ref$storageKey = _ref.storageKey,\n        storageKey = _ref$storageKey === undefined ? 'default' : _ref$storageKey,\n        _ref$persist = _ref.persist,\n        persist = _ref$persist === undefined ? false : _ref$persist;\n\n    _classCallCheck(this, Nexustate);\n\n    this.setPersistenceFunctions = function (save, load) {\n      _this.saveCallback = save;\n      _this.loadCallback = load;\n    };\n\n    this.setPersist = function (shouldPersist) {\n      _this.persist = shouldPersist;\n    };\n\n    this.get = function () {\n      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var defaultValue = arguments[1];\n\n      return _this.storageManager.get(key, defaultValue);\n    };\n\n    this.createPassthroughKeyValueFunction = function (functionName) {\n      return function (key, value) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n        var batch = _this.getChangeNotificationBatch(key, value, options);\n        var result = _this.storageManager[functionName](key, value, options);\n        _this.finalizeChange(batch, options);\n        return result;\n      };\n    };\n\n    this.createPassthroughKeyOnlyFunction = function (functionName, notificationValue) {\n      return function (key) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_OPTIONS;\n\n        var batch = _this.getChangeNotificationBatch(key, notificationValue, options);\n        var result = _this.storageManager[functionName](key, options);\n        _this.finalizeChange(batch, options);\n        return result;\n      };\n    };\n\n    this.assign = this.createPassthroughKeyValueFunction('assign', ['key', 'value']);\n    this.set = this.createPassthroughKeyValueFunction('set', ['key', 'value']);\n    this.setKey = this.createPassthroughKeyValueFunction('set', ['key', 'value']);\n    this.push = this.createPassthroughKeyValueFunction('push', ['key', 'value']);\n    this.pop = this.createPassthroughKeyValueFunction('pop', ['key']);\n    this.delete = this.createPassthroughKeyOnlyFunction('delete', null, ['key']);\n\n    this.assureExists = function (key, defaultValue) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n      if (!_this.has(key)) {\n        return _this.set(key, defaultValue, options);\n      }\n    };\n\n    this.has = function () {\n      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return _this.storageManager.has(key);\n    };\n\n    this.getForListener = function (listener, keyChange) {\n      var key = listener.key,\n          alias = listener.alias,\n          callback = listener.callback,\n          transform = listener.transform;\n\n      var value = _this.storageManager.get(key);\n\n      return { keyChange: keyChange, alias: alias, callback: callback, key: key, value: transform ? transform(value) : value };\n    };\n\n    this.persistData = function () {\n      var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (immediate) {\n        _this.save();\n      } else {\n        _this.throttledSave();\n      }\n    };\n\n    this.save = function () {\n      return _this.saveCallback(_this.storageKey, _this.storageManager.get());\n    };\n\n    this.load = function () {\n      var loadResults = _this.loadCallback(_this.storageKey);\n\n      if (loadResults instanceof Promise) {\n        return loadResults.then(function (data) {\n          _this.setKey(null, data);\n        });\n      }\n\n      return _this.setKey(null, loadResults);\n    };\n\n    this.throttledSave = (0, _NexustateHelpers.throttle)(this.save, SAVE_THROTTLE_TIME);\n\n    this.getAllChildListeners = function (listenerObject) {\n      var currentKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var result = [];\n      var currentListeners = (0, _objer.get)(listenerObject, 'listeners') || [];\n      var subkeyObject = (0, _objer.get)(listenerObject, 'subkeys') || {};\n      var subkeys = (0, _objer.keys)(subkeyObject);\n      for (var listenerdex = 0; listenerdex < currentListeners.length; listenerdex += 1) {\n        result.push({ listener: currentListeners[listenerdex], key: currentKey });\n      }\n      for (var keydex = 0; keydex < subkeys.length; keydex += 1) {\n        var subkey = subkeys[keydex];\n        result = result.concat(_this.getAllChildListeners(subkeyObject[subkey], currentKey.concat(subkey)));\n      }\n      return result;\n    };\n\n    this.getMissingChildListeners = function (original, incoming, listenerObject) {\n      var currentKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n      // recurse original against incoming for changed keys, if original type is an object or array and incoming type is not the same\n      // pass all child listeners. If incoming and original are both either objects or arrays, recurse the children using this function.\n      var result = [];\n      var originalType = (0, _objer.getTypeString)(original);\n      if (originalType === 'object' || originalType === 'array') {\n        var incomingType = (0, _objer.getTypeString)(incoming);\n        if (incomingType !== originalType) {\n          result = result.concat(_this.getAllChildListeners(listenerObject, currentKey));\n          // Send delete notification to every child of the original key\n        } else {\n          var originalKeys = (0, _objer.keys)(original);\n          if ((0, _objer.has)(listenerObject, 'subkeys')) {\n            for (var keydex = 0; keydex < originalKeys.length; keydex += 1) {\n              var originalKey = originalKeys[keydex];\n              if ((0, _objer.has)(listenerObject.subkeys, originalKey)) {\n                if (!(0, _objer.has)(incoming, originalKey)) {\n                  result = result.concat(_this.getAllChildListeners(listenerObject.subkeys[originalKey], currentKey.concat(originalKey)));\n                } else {\n                  result = result.concat(_this.getMissingChildListeners((0, _objer.get)(original, originalKey), (0, _objer.get)(incoming, originalKey), listenerObject.subkeys[originalKey], currentKey.concat(originalKey)));\n                }\n              }\n            }\n          }\n          // Recursively check children against incoming, for any missing keys send deletion, additions and changes are handled by other recurse function\n        }\n      }\n      return result;\n    };\n\n    this.getNotifyBatch = function (_ref2) {\n      var key = _ref2.key,\n          value = _ref2.value;\n\n      var keyArray = key !== null ? (0, _objer.getObjectPath)(key) : [];\n      var listenersWithKeys = _this.recurseMatchingPathsForListeners((0, _NexustateHelpers.getKeyFilledObject)(key, value), _this.listenerObject, [], keyArray.length); // this kills the specificity arrangement\n      var deletersWithKeys = _this.recurseDeletedPathsForListeners({ key: keyArray, value: value }); // this kills the\n\n      return listenersWithKeys.concat(deletersWithKeys);\n    };\n\n    this.notify = function (_ref3) {\n      var key = _ref3.key,\n          value = _ref3.value;\n\n      _this.executeNotifyBatch(_this.getNotifyBatch({ key: key, value: value }));\n    };\n\n    this.listen = function () {\n      var listener = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { key: null, callback: function callback() {}, alias: null, component: null, transform: null, noChildUpdates: false };\n\n      var listeners = _this.getListenersAtPath(listener.key);\n      var matchedListeners = listeners.reduce(function (results, existingListener, dex) {\n        if (existingListener.callback === listener.callback) results.push(dex);\n        return results;\n      }, []);\n\n      for (var dex = matchedListeners.length - 1; dex >= 0; dex -= 1) {\n        listeners.splice(matchedListeners[dex], 1);\n      }\n\n      listeners.push(listener);\n      return true;\n    };\n\n    this.getListenersAtPath = function (key) {\n      if ((0, _blankKey.isBlankKey)(key)) return (0, _objer.assurePathExists)(_this.listenerObject, 'listeners', []);\n      var keyArray = (0, _objer.getObjectPath)(key);\n\n      var currentListenObject = _this.listenerObject;\n      for (var keydex = 0; keydex < keyArray.length - 1; keydex += 1) {\n        // Go through all keys except the last, which is where out final request will go\n        var subKey = keyArray[keydex];\n        currentListenObject = (0, _objer.assurePathExists)(currentListenObject, ['subkeys', subKey], {});\n      }\n      var finalKey = keyArray[keyArray.length - 1];\n      return (0, _objer.assurePathExists)(currentListenObject, ['subkeys', finalKey, 'listeners'], []);\n    };\n\n    this.unlisten = function (key, callback) {\n      var listeners = _this.getListenersAtPath(key);\n\n      var matchedListeners = listeners.reduce(function (results, existingListener, dex) {\n        if (existingListener.callback === callback) results.push(dex);\n        return results;\n      }, []);\n\n      for (var dex = matchedListeners.length - 1; dex >= 0; dex -= 1) {\n        listeners.splice(matchedListeners[dex], 1);\n      }\n    };\n\n    this.unlistenComponent = function (component, basePath) {\n      var patharray = basePath || [];\n      var subkeypath = (basePath || []).concat('subkeys');\n      var subKeys = (0, _objer.keys)((0, _objer.get)(_this.listenerObject, subkeypath));\n      for (var keydex = 0; keydex < subKeys.length; keydex += 1) {\n        _this.unlistenComponent(component, subkeypath.concat([subKeys[keydex]]));\n      }\n\n      var listeners = (0, _objer.get)(_this.listenerObject, patharray.concat('listeners'));\n\n      var matchedListeners = (listeners || []).reduce(function (results, existingListener, dex) {\n        if (existingListener.component === component) results.push(dex);\n        return results;\n      }, []);\n\n      for (var dex = matchedListeners.length - 1; dex >= 0; dex -= 1) {\n        listeners.splice(matchedListeners[dex], 1);\n      }\n    };\n\n    this.storageManager = new _StorageManager2.default();\n    this.listenerObject = { subkeys: {} };\n    this.storageKey = storageKey;\n    this.saveCallback = saveCallback || Nexustate.defaultSaveCallback;\n    this.loadCallback = loadCallback || Nexustate.defaultLoadCallback;\n    this.persist = persist;\n  }\n\n  _createClass(Nexustate, [{\n    key: 'setOptions',\n    value: function setOptions() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          saveCallback = _ref4.saveCallback,\n          loadCallback = _ref4.loadCallback,\n          storageKey = _ref4.storageKey,\n          persist = _ref4.persist;\n\n      if (storageKey !== undefined) this.storageKey = storageKey;\n      if (saveCallback !== undefined) this.saveCallback = saveCallback;\n      if (loadCallback !== undefined) this.loadCallback = loadCallback;\n      if (persist !== undefined) this.persist = persist;\n    }\n  }, {\n    key: 'getChangeNotificationBatch',\n    value: function getChangeNotificationBatch(key, value, options) {\n      if (!options.noNotify) return this.getNotifyBatch({ key: key, value: value });\n      return [];\n    }\n  }, {\n    key: 'finalizeChange',\n    value: function finalizeChange(batch, options) {\n      if (this.persist) this.persistData(options.immediatePersist);\n      if (!options.noNotify) this.executeNotifyBatch(batch);\n    }\n    // splice = this.createPassthroughKeyValueFunction('splice', ['key', 'index', 'length']);\n    // unshift = this.createPassthroughKeyValueFunction('unshift', ['key']);\n    // shift = this.createPassthroughKeyValueFunction('shift', ['key']);\n\n  }, {\n    key: 'executeNotifyBatch',\n    value: function executeNotifyBatch(notifyBatch) {\n      var _this2 = this;\n\n      var result = [];\n      var callbackBatches = []; // Use this to detect multiple listeners, okay for now, need to use an object somehow in the future\n      // [{ callback: () => {}, changes: [{ getForListener() Result }]}]\n\n      var _loop = function _loop(keydex) {\n        var keyChange = notifyBatch[keydex];\n        var listenerIndex = (0, _NexustateHelpers.findIndex)(callbackBatches, function (callbackBatch) {\n          return callbackBatch.callback === keyChange.listener.callback;\n        });\n\n        if (listenerIndex !== -1) {\n          callbackBatches[listenerIndex].changes.push(_this2.getForListener(keyChange.listener, keyChange.key));\n        } else {\n          callbackBatches.push({ callback: keyChange.listener.callback, changes: [_this2.getForListener(keyChange.listener, keyChange.key)] });\n        }\n      };\n\n      for (var keydex = 0; keydex < notifyBatch.length; keydex += 1) {\n        _loop(keydex);\n      }\n\n      for (var callbatch = 0; callbatch < callbackBatches.length; callbatch += 1) {\n        var listenerBatch = callbackBatches[callbatch];\n        var callback = listenerBatch.callback,\n            changes = listenerBatch.changes;\n\n\n        callback(changes);\n      }\n    }\n  }, {\n    key: 'recurseMatchingPathsForListeners',\n    value: function recurseMatchingPathsForListeners(change, listenerObject) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var originalChangeDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var currentChangeDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n      var changeRelativity = originalChangeDepth - currentChangeDepth; // Parent change > 0, child change < 0, currentChange == 0\n      var result = [];\n      if ((0, _objer.has)(listenerObject, 'listeners')) {\n        for (var listenerdex = 0; listenerdex < listenerObject.listeners.length; listenerdex += 1) {\n          var listener = listenerObject.listeners[listenerdex];\n          if (listener.noChildUpdates === true && changeRelativity > 0) {} // Skip informing parents who don't care\n          else if (listener.noParentUpdates === true && changeRelativity < 0) {} // Skip informing children who don't care\n            else {\n                result.push({ listener: listener, key: key });\n              }\n        }\n      }\n\n      if ((0, _objer.has)(listenerObject, 'subkeys') && (change instanceof Array || (typeof change === 'undefined' ? 'undefined' : _typeof(change)) === 'object')) {\n        var changeKeys = (0, _objer.keys)(change);\n        for (var keydex = 0; keydex < changeKeys.length; keydex += 1) {\n          var changeKey = changeKeys[keydex];\n          if ((0, _objer.has)(listenerObject.subkeys, changeKey)) {\n            result = result.concat(this.recurseMatchingPathsForListeners(change[changeKey], listenerObject.subkeys[changeKey], key.concat(changeKey), originalChangeDepth, currentChangeDepth + 1));\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: 'getListenerObjectAtKey',\n    value: function getListenerObjectAtKey(key) {\n      var result = this.listenerObject;\n      for (var keydex = 0; keydex < key.length; keydex += 1) {\n        if ((0, _objer.has)(result, ['subkeys', key[keydex]])) {\n          result = result.subkeys[key[keydex]];\n        } else {\n          return null;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: 'recurseDeletedPathsForListeners',\n    value: function recurseDeletedPathsForListeners(_ref5) {\n      var key = _ref5.key,\n          value = _ref5.value;\n\n      var original = this.storageManager.get(key);\n      var listeners = this.getMissingChildListeners(original, value, this.getListenerObjectAtKey(key), key);\n      return listeners;\n    }\n  }]);\n\n  return Nexustate;\n}();\n\nNexustate.defaultSaveCallback = missingCallback;\nNexustate.defaultLoadCallback = missingCallback;\nexports.default = Nexustate;\n\n//# sourceURL=webpack://nexusdk/./src/Nexustate.js?");

/***/ }),

/***/ "./src/NexustateAgent.js":
/*!*******************************!*\
  !*** ./src/NexustateAgent.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _objer = __webpack_require__(/*! objer */ \"./node_modules/objer/dist/src/node.index.js\");\n\nvar _clone = __webpack_require__(/*! clone */ \"./node_modules/clone/clone.js\");\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _getShardedNexustate = __webpack_require__(/*! ./getShardedNexustate */ \"./src/getShardedNexustate.js\");\n\nvar _getShardedNexustate2 = _interopRequireDefault(_getShardedNexustate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getUnclonedComposedState(initialData, key, value) {\n  if (key === null) return value;\n\n  (0, _objer.set)(initialData, key, value);\n  return initialData;\n}\n\nfunction getClonedComposedState(initialData, key, value) {\n  return getUnclonedComposedState((0, _clone2.default)(initialData), key, value);\n}\n\nvar NexustateAgent = function () {\n  function NexustateAgent() {\n    var _this = this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$shardedNexustate = _ref.shardedNexustate,\n        shardedNexustate = _ref$shardedNexustate === undefined ? null : _ref$shardedNexustate,\n        _ref$cloneBeforeSet = _ref.cloneBeforeSet,\n        cloneBeforeSet = _ref$cloneBeforeSet === undefined ? false : _ref$cloneBeforeSet,\n        _ref$onChange = _ref.onChange,\n        onChange = _ref$onChange === undefined ? null : _ref$onChange;\n\n    _classCallCheck(this, NexustateAgent);\n\n    this.createShard = function (shard, options) {\n      return _this.shardState.createShard(shard, options);\n    };\n\n    this.unlisten = function (key) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$shard = _ref2.shard,\n          shard = _ref2$shard === undefined ? 'default' : _ref2$shard,\n          _ref2$resetState = _ref2.resetState,\n          resetState = _ref2$resetState === undefined ? false : _ref2$resetState;\n\n      var result = _this.shardState.getShard(shard).unlisten(key, _this.handleChange);\n      if (resetState) _this.data = {};\n      return result;\n    };\n\n    this.unlistenFromAll = function () {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$resetState = _ref3.resetState,\n          resetState = _ref3$resetState === undefined ? true : _ref3$resetState;\n\n      var shards = (0, _objer.values)(_this.shardState.getAllShards());\n      for (var sharddex = 0; sharddex < shards.length; sharddex += 1) {\n        shards[sharddex].unlistenComponent(_this);\n      }\n      if (resetState) _this.data = {};\n    };\n\n    this.setComposedState = function (key, value) {\n      _this.data = _this.getComposedState(_this.data, key, value);\n    };\n\n    this.listen = function (_ref4) {\n      var _ref4$shard = _ref4.shard,\n          shard = _ref4$shard === undefined ? 'default' : _ref4$shard,\n          key = _ref4.key,\n          alias = _ref4.alias,\n          transform = _ref4.transform,\n          _ref4$initialLoad = _ref4.initialLoad,\n          initialLoad = _ref4$initialLoad === undefined ? true : _ref4$initialLoad,\n          noChildUpdates = _ref4.noChildUpdates,\n          noParentUpdates = _ref4.noParentUpdates;\n      var partOfMultiListen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var manager = _this.shardState.getShard(shard);\n      var modifiedListener = {\n        shard: shard,\n        key: key,\n        alias: alias,\n        transform: transform,\n        initialLoad: initialLoad,\n        noChildUpdates: noChildUpdates,\n        noParentUpdates: noParentUpdates,\n        callback: _this.handleChange,\n        component: _this\n      };\n      manager.listen(modifiedListener);\n\n      if (initialLoad) {\n        var listenData = manager.getForListener(modifiedListener);\n        _this.setComposedState(listenData.alias || listenData.key, listenData.value);\n        if (!partOfMultiListen && _this.onChange) {\n          _this.onChange(_this.data);\n        }\n      }\n    };\n\n    this.multiListen = function (listeners) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref5$initialLoad = _ref5.initialLoad,\n          initialLoad = _ref5$initialLoad === undefined ? false : _ref5$initialLoad;\n\n      var loaded = false;\n\n      for (var listenerdex = 0; listenerdex < listeners.length; listenerdex += 1) {\n        _this.listen(listeners[listenerdex], true);\n        if (initialLoad) {\n          loaded = true;\n          var manager = _this.shardState.getShard(listeners[listenerdex].shard || 'default');\n          var listenData = manager.getForListener(listeners[listenerdex]);\n          _this.setComposedState(listenData.alias || listenData.key, listenData.value);\n        }\n      }\n\n      if (loaded && _this.onChange) {\n        _this.onChange(_this.data);\n      }\n    };\n\n    this.handleChange = function (changeEvents) {\n      for (var changedex = 0; changedex < changeEvents.length; changedex += 1) {\n        var changeEvent = changeEvents[changedex];\n        var alias = changeEvent.alias,\n            key = changeEvent.key,\n            value = changeEvent.value;\n\n        _this.setComposedState(alias || key, value);\n      }\n\n      if (_this.onChange) {\n        _this.onChange(_this.data);\n      }\n    };\n\n    this.get = function (path) {\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref6$defaultValue = _ref6.defaultValue,\n          defaultValue = _ref6$defaultValue === undefined ? undefined : _ref6$defaultValue,\n          _ref6$shard = _ref6.shard,\n          shard = _ref6$shard === undefined ? 'default' : _ref6$shard;\n\n      return _this.shardState.getShard(shard).get(path, defaultValue);\n    };\n\n    this.delete = function (path) {\n      var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref7$shard = _ref7.shard,\n          shard = _ref7$shard === undefined ? 'default' : _ref7$shard;\n\n      return _this.shardState.getShard(shard).delete(path);\n    };\n\n    this.set = function (path, data) {\n      var _ref8 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref8$shard = _ref8.shard,\n          shard = _ref8$shard === undefined ? 'default' : _ref8$shard;\n\n      return _this.shardState.getShard(shard).set(path, data);\n    };\n\n    this.setKey = function (path, data) {\n      var _ref9 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref9$shard = _ref9.shard,\n          shard = _ref9$shard === undefined ? 'default' : _ref9$shard;\n\n      return _this.shardState.getShard(shard).setKey(path, data);\n    };\n\n    this.push = function (path, data) {\n      var _ref10 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref10$shard = _ref10.shard,\n          shard = _ref10$shard === undefined ? 'default' : _ref10$shard;\n\n      return _this.shardState.getShard(shard).push(path, data);\n    };\n\n    this.assign = function (path, data) {\n      var _ref11 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref11$shard = _ref11.shard,\n          shard = _ref11$shard === undefined ? 'default' : _ref11$shard;\n\n      return _this.shardState.getShard(shard).assign(path, data);\n    };\n\n    this.assureExists = function (path, defaultValue) {\n      var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref12$shard = _ref12.shard,\n          shard = _ref12$shard === undefined ? 'default' : _ref12$shard;\n\n      return _this.shardState.getShard(shard).assureExists(path, defaultValue);\n    };\n\n    this.getShard = function () {\n      var shard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n\n      return _this.shardState.getShard(shard);\n    };\n\n    this.data = {};\n    this.onChange = onChange;\n    this.shardState = shardedNexustate || (0, _getShardedNexustate2.default)();\n\n    if (cloneBeforeSet) {\n      this.getComposedState = getClonedComposedState;\n    } else {\n      this.getComposedState = getUnclonedComposedState;\n    }\n  }\n\n  _createClass(NexustateAgent, [{\n    key: 'cleanup',\n    value: function cleanup() {\n      return this.unlistenFromAll();\n    }\n  }]);\n\n  return NexustateAgent;\n}();\n\nexports.default = NexustateAgent;\n\n//# sourceURL=webpack://nexusdk/./src/NexustateAgent.js?");

/***/ }),

/***/ "./src/NexustateHelpers.js":
/*!*********************************!*\
  !*** ./src/NexustateHelpers.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findIndex = findIndex;\nexports.throttle = throttle;\nexports.getKeyFilledObject = getKeyFilledObject;\n\nvar _objer = __webpack_require__(/*! objer */ \"./node_modules/objer/dist/src/node.index.js\");\n\nfunction findIndex(array, callback, context) {\n  for (var keydex = 0; keydex < array.length; keydex += 1) {\n    if (callback(array[keydex])) return keydex;\n  }\n  return -1;\n}\n\n// ** COPIED FROM UNDERSCORE JS **\n// Returns a function, that, when invoked, will only be triggered at most once\n// during a given window of time. Normally, the throttled function will run\n// as much as it can, without ever going more than once per `wait` duration;\n// but if you'd like to disable the execution on the leading edge, pass\n// `{leading: false}`. To disable execution on the trailing edge, ditto.\nfunction throttle(func, wait, options) {\n  var timeout, context, args, result;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function later() {\n    previous = options.leading === false ? 0 : new Date().getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  var throttled = function throttled() {\n    var now = new Date().getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n\n  throttled.cancel = function () {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = context = args = null;\n  };\n\n  return throttled;\n}\n\nfunction getKeyFilledObject(key, value) {\n  if (key === null) return value;\n  var result = {};\n  (0, _objer.assurePathExists)(result, key);\n  (0, _objer.set)(result, key, value);\n  return result;\n}\n\n//# sourceURL=webpack://nexusdk/./src/NexustateHelpers.js?");

/***/ }),

/***/ "./src/ShardedNexustate.js":
/*!*********************************!*\
  !*** ./src/ShardedNexustate.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Nexustate = __webpack_require__(/*! ./Nexustate */ \"./src/Nexustate.js\");\n\nvar _Nexustate2 = _interopRequireDefault(_Nexustate);\n\nvar _objer = __webpack_require__(/*! objer */ \"./node_modules/objer/dist/src/node.index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ShardedNexustate = function () {\n  function ShardedNexustate() {\n    var _this = this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        saveCallback = _ref.saveCallback,\n        loadCallback = _ref.loadCallback;\n\n    _classCallCheck(this, ShardedNexustate);\n\n    this.getShard = function () {\n      var shard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n      var options = arguments[1];\n\n      if (!_this.dataManagerShards[shard]) {\n        var passOptions = Object.assign({ storageKey: shard }, _this.defaultOptions || {}, options || {});\n        _this.dataManagerShards[shard] = new _Nexustate2.default(passOptions);\n      }\n      return _this.dataManagerShards[shard];\n    };\n\n    this.createShard = function (shard, options) {\n      return _this.getShard(shard, options);\n    };\n\n    this.getAllShards = function () {\n      return _this.dataManagerShards;\n    };\n\n    this.loadShards = function (shardList) {\n      var promises = [];\n      (shardList || []).forEach(function (shard) {\n        var typeString = (0, _objer.getTypeString)(shard);\n        var loadedShard = null;\n        if (typeString === 'object') {\n          var name = shard.name,\n              persist = shard.persist;\n\n          loadedShard = _this.getShard(name, { persist: persist });\n          loadedShard.setOptions({ persist: persist });\n        } else if (typeString === 'string') {\n          loadedShard = _this.getShard(shard);\n        }\n\n        if (loadedShard) {\n          var loadResult = loadedShard.load();\n          var loadResultType = (0, _objer.getTypeString)(loadResult);\n          if (loadResultType === 'promise' || loadResult instanceof Promise) {\n            promises.push(loadResult);\n          } else {\n            promises.push(Promise.resolve(loadResult));\n          }\n        }\n      });\n      return Promise.all(promises);\n    };\n\n    this.dataManagerShards = {};\n    this.defaultOptions = {\n      saveCallback: saveCallback,\n      loadCallback: loadCallback\n    };\n  }\n\n  _createClass(ShardedNexustate, [{\n    key: 'setAllPersistenceFunctions',\n    value: function setAllPersistenceFunctions(saveCallback, loadCallback) {\n      this.defaultOptions.saveCallback = saveCallback;\n      this.defaultOptions.loadCallback = loadCallback;\n      (0, _objer.values)(this.dataManagerShards).forEach(function (manager) {\n        manager.setPersistenceFunctions(saveCallback, loadCallback);\n      });\n    }\n  }]);\n\n  return ShardedNexustate;\n}();\n\nexports.default = ShardedNexustate;\n\n//# sourceURL=webpack://nexusdk/./src/ShardedNexustate.js?");

/***/ }),

/***/ "./src/StorageManager.js":
/*!*******************************!*\
  !*** ./src/StorageManager.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _objer = __webpack_require__(/*! objer */ \"./node_modules/objer/dist/src/node.index.js\");\n\nvar _blankKey = __webpack_require__(/*! ./utility/blankKey */ \"./src/utility/blankKey.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StorageManager = function () {\n  function StorageManager() {\n    _classCallCheck(this, StorageManager);\n\n    this.data = {};\n  }\n\n  _createClass(StorageManager, [{\n    key: 'set',\n    value: function set(key, value) {\n      if ((0, _blankKey.isBlankKey)(key)) {\n        this.data = value;\n        return this.data;\n      }\n      if (this.data === null) this.data = {};\n      return (0, _objer.set)(this.data, key, value);\n    }\n  }, {\n    key: 'assign',\n    value: function assign(key, value) {\n      var currentData = (0, _objer.get)(this.data, key);\n      var currentType = (0, _objer.getTypeString)(currentData);\n      var incomingType = (0, _objer.getTypeString)(value);\n      if (currentType === 'object' && incomingType === 'object') {\n        return this.set(key, Object.assign(currentData, value));\n      }\n\n      return this.set(key, value);\n    }\n  }, {\n    key: 'assureExists',\n    value: function assureExists(key, defaultValue) {\n      if ((0, _blankKey.isBlankKey)(key)) {\n        if (this.data === undefined) {\n          this.data = defaultValue;\n          return true;\n        }\n      } else {\n        return (0, _objer.assurePathExists)(this.data, key, defaultValue);\n      }\n      return false;\n    }\n  }, {\n    key: 'get',\n    value: function get() {\n      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var defaultValue = arguments[1];\n\n      return (0, _blankKey.isBlankKey)(key) ? this.data : (0, _objer.get)(this.data, key, defaultValue);\n    }\n  }, {\n    key: 'has',\n    value: function has() {\n      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return (0, _blankKey.isBlankKey)(key) ? this.data !== undefined : (0, _objer.has)(this.data, key);\n    }\n  }, {\n    key: 'delete',\n    value: function _delete(key) {\n      var keyArray = (0, _objer.getObjectPath)(key);\n      var value = this.data;\n      for (var keydex = 0; keydex < keyArray.length - 1; keydex += 1) {\n        value = value[keyArray[keydex]];\n      }\n      var finalKey = keyArray[keyArray.length - 1];\n      if (value instanceof Array && toString.call(finalKey) === '[object Number]') {\n        value.splice(finalKey, 1);\n      } else {\n        if ((0, _objer.getTypeString)(value) === 'object') {\n          delete value[finalKey];\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'push',\n    value: function push(key, value) {\n      if ((0, _blankKey.isBlankKey)(key)) this.data.push(value);\n      if (this.data === null) this.data = {};\n      (0, _objer.assurePathExists)(this.data, key, []);\n      this.get(key).push(value);\n    }\n  }, {\n    key: 'pop',\n    value: function pop(key, value) {\n      if ((0, _blankKey.isBlankKey)(key)) this.data.pop(value);\n      if (this.data === null) this.data = {};\n      (0, _objer.get)(this.data, key).pop(value);\n    }\n  }, {\n    key: 'unshift',\n    value: function unshift(key, value) {\n      if ((0, _blankKey.isBlankKey)(key)) this.data.unshift(value);\n      if (this.data === null) this.data = {};\n      (0, _objer.get)(this.data, key).unshift(value);\n    }\n  }, {\n    key: 'shift',\n    value: function shift(key, value) {\n      if ((0, _blankKey.isBlankKey)(key)) this.data.shift(value);\n      if (this.data === null) this.data = {};\n      (0, _objer.get)(this.data, key).shift(value);\n    }\n  }, {\n    key: 'splice',\n    value: function splice(key, index, length) {\n      if ((0, _blankKey.isBlankKey)(key)) this.data.splice(index, length);\n      if (this.data === null) this.data = {};\n      (0, _objer.get)(this.data, key).splice(index, length);\n    }\n  }]);\n\n  return StorageManager;\n}();\n\nexports.default = StorageManager;\n\n//# sourceURL=webpack://nexusdk/./src/StorageManager.js?");

/***/ }),

/***/ "./src/getNexustate.js":
/*!*****************************!*\
  !*** ./src/getNexustate.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getNexustate;\n\nvar _Nexustate = __webpack_require__(/*! ./Nexustate */ \"./src/Nexustate.js\");\n\nvar _Nexustate2 = _interopRequireDefault(_Nexustate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Get global instance of nexustate with a given name, pass options to instantiate with options\n * @param {string} name\n * @param {object} options\n * @param {boolean} options.persist\n */\nfunction getNexustate() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n  var options = arguments[1];\n\n  if (getNexustate.managers === undefined) getNexustate.managers = {};\n  if (getNexustate.managers[name] === undefined) {\n    var passOptions = Object.assign({}, { saveCallback: null, loadCallback: null, persist: false, storageKey: name }, options || {});\n    getNexustate.managers[name] = new _Nexustate2.default(passOptions);\n    if (passOptions.persist) {\n      getNexustate.managers[name].load();\n    }\n  };\n  return getNexustate.managers[name];\n}\n\n//# sourceURL=webpack://nexusdk/./src/getNexustate.js?");

/***/ }),

/***/ "./src/getShardedNexustate.js":
/*!************************************!*\
  !*** ./src/getShardedNexustate.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getShardedNexustate;\n\nvar _ShardedNexustate = __webpack_require__(/*! ./ShardedNexustate */ \"./src/ShardedNexustate.js\");\n\nvar _ShardedNexustate2 = _interopRequireDefault(_ShardedNexustate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getShardedNexustate() {\n  if (!getShardedNexustate.shardedNexustate) {\n    getShardedNexustate.shardedNexustate = new _ShardedNexustate2.default();\n  }\n\n  return getShardedNexustate.shardedNexustate;\n}\n\n//# sourceURL=webpack://nexusdk/./src/getShardedNexustate.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NexustateAgent = exports.getShardedNexustate = exports.ShardedNexustate = exports.getNexustate = exports.Nexustate = undefined;\n\nvar _Nexustate = __webpack_require__(/*! ./Nexustate */ \"./src/Nexustate.js\");\n\nvar _Nexustate2 = _interopRequireDefault(_Nexustate);\n\nvar _getNexustate = __webpack_require__(/*! ./getNexustate */ \"./src/getNexustate.js\");\n\nvar _getNexustate2 = _interopRequireDefault(_getNexustate);\n\nvar _ShardedNexustate = __webpack_require__(/*! ./ShardedNexustate */ \"./src/ShardedNexustate.js\");\n\nvar _ShardedNexustate2 = _interopRequireDefault(_ShardedNexustate);\n\nvar _getShardedNexustate = __webpack_require__(/*! ./getShardedNexustate */ \"./src/getShardedNexustate.js\");\n\nvar _getShardedNexustate2 = _interopRequireDefault(_getShardedNexustate);\n\nvar _NexustateAgent = __webpack_require__(/*! ./NexustateAgent */ \"./src/NexustateAgent.js\");\n\nvar _NexustateAgent2 = _interopRequireDefault(_NexustateAgent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Nexustate = _Nexustate2.default;\nexports.getNexustate = _getNexustate2.default;\nexports.ShardedNexustate = _ShardedNexustate2.default;\nexports.getShardedNexustate = _getShardedNexustate2.default;\nexports.NexustateAgent = _NexustateAgent2.default;\n\n//# sourceURL=webpack://nexusdk/./src/index.js?");

/***/ }),

/***/ "./src/utility/blankKey.js":
/*!*********************************!*\
  !*** ./src/utility/blankKey.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBlankKey = isBlankKey;\nfunction isBlankKey(key) {\n  return key === null || key instanceof Array && key.length === 0;\n}\n\n//# sourceURL=webpack://nexusdk/./src/utility/blankKey.js?");

/***/ })

/******/ });
});